extends Resource

## Farm Plot - Dual-Emoji Qubit System
## Represents a single farm plot with different plant types
## All plants are dual-emoji qubits (50/50 superposition when planted):
## Wheat: ğŸŒ¾ (Natural Growth) â†” ğŸ‘¥ (Labor)
## Tomato: ğŸ… (Tomato) â†” ğŸ (Sauce)
## Mushroom: ğŸ„ (Mushroom) â†” ğŸ‚ (Detritus)

# Preload quantum state
const DualEmojiQubit = preload("res://Core/QuantumSubstrate/DualEmojiQubit.gd")

signal growth_complete
signal state_collapsed(final_state: String)

# Plot type
enum PlotType { WHEAT, TOMATO, MUSHROOM, MILL, MARKET }
@export var plot_type: PlotType = PlotType.WHEAT

# Plot identification
@export var plot_id: String = ""
@export var grid_position: Vector2i = Vector2i.ZERO

# Conspiracy network connection
@export var conspiracy_node_id: String = ""  # Which node this plot is entangled with
@export var conspiracy_bond_strength: float = 0.0  # Bond strength (increased by measurement)

# Dual-emoji qubit states (plot-type-specific)
# Global fallback for wheat
const EMOJI_NORTH = "ğŸŒ¾"  # Natural growth (theta = 0)
const EMOJI_SOUTH = "ğŸ‘¥"  # Labor intensive (theta = PI)

# Quantum state (upgraded to use DualEmojiQubit!)
var quantum_state: DualEmojiQubit = null

# Legacy accessors for compatibility
@export var theta: float:
	get: return quantum_state.theta if quantum_state else PI/2.0
	set(value): if quantum_state: quantum_state.theta = value

@export var phi: float:
	get: return quantum_state.phi if quantum_state else 0.0
	set(value): if quantum_state: quantum_state.phi = value

# Quantum state
@export var is_planted: bool = false
@export var has_been_measured: bool = false
@export var theta_frozen: bool = false  # True after measurement - stops theta drift

# PHYSICS MODEL (Quantum-Only, No Classical Growth):
# - NO growth_progress - plants appear instantly at full size
# - NO maturity threshold - can measure/harvest immediately
# - theta = Probability ratio P(ğŸŒ¾)/P(ğŸ‘¥) - manipulated via entanglement
# - Gameplay: Plant â†’ Manipulate theta â†’ Measure â†’ Harvest

# Berry phase accumulator (plot memory)
@export var replant_cycles: int = 0
@export var berry_phase: float = 0.0

# Entanglement
var entangled_plots: Dictionary = {}  # plot_id -> strength (quantum state entanglement, temporary)
var plot_infrastructure_entanglements: Array[Vector2i] = []  # PERSISTENT plot-level entanglement gates
const MAX_ENTANGLEMENTS = 3

# Quantum evolution parameters
const THETA_DRIFT_RATE = 0.1  # How fast theta drifts toward target
const THETA_ENTANGLED_TARGET = PI / 2.0  # Target for entangled (superposition)
const THETA_ISOLATED_TARGET = 0.0  # Target for isolated (certain wheat)

# Harvest bonuses
const ENTANGLEMENT_BONUS = 0.20  # +20% yield per entangled neighbor
const BERRY_PHASE_BONUS = 0.05  # +5% yield per replant cycle
const OBSERVER_PENALTY = 0.10  # -10% final yield if measured


func _init():
	plot_id = "plot_%d" % randi()


## Helper Functions

func get_plot_emojis() -> Dictionary:
	"""Get the dual-emoji pair for this plot type"""
	match plot_type:
		PlotType.WHEAT:
			return {"north": "ğŸŒ¾", "south": "ğŸ‘¥"}  # Wheat â†” Labor
		PlotType.TOMATO:
			return {"north": "ğŸ…", "south": "ğŸ"}  # Tomato â†” Sauce
		PlotType.MUSHROOM:
			return {"north": "ğŸ„", "south": "ğŸ‚"}  # Mushroom â†” Detritus
		_:
			return {"north": "ğŸŒ¾", "south": "ğŸ‘¥"}  # Default to wheat


## Planting

func plant():
	"""Plant crop in this plot (instant full size, 50/50 superposition)"""
	if is_planted:
		return

	# Get plot-type-specific emojis
	var emojis = get_plot_emojis()

	# Create quantum state with dual-emoji qubit
	# PHYSICS: Start at Î¸=Ï€/2 (equal superposition - 50/50 split)
	# Theta represents PROBABILITY RATIO (separate from growth/size)
	quantum_state = DualEmojiQubit.new(emojis["north"], emojis["south"], PI/2.0)
	quantum_state.phi = randf() * TAU  # Random initial phase
	quantum_state.enable_berry_phase()  # Enable geometric phase tracking

	# CRITICAL: Entangle wheat/mushrooms with solar conspiracy node!
	# Wheat absorbs energy from sun during sun phase through quantum entanglement
	# Mushrooms absorb energy from moon during moon phase
	# This uses the EXISTING conspiracy network - no separate environment system!
	if plot_type == PlotType.WHEAT:
		conspiracy_node_id = "solar"  # Connect to sun/moon node
	elif plot_type == PlotType.MUSHROOM:
		conspiracy_node_id = "solar"  # Same node, opposite phase!

	is_planted = true
	has_been_measured = false
	theta_frozen = false  # Quantum state is active

	match plot_type:
		PlotType.WHEAT:
			print("ğŸŒ± Planted wheat at %s â†’ entangled with â˜€ï¸ solar node (sun phase)" % plot_id)
		PlotType.MUSHROOM:
			print("ğŸ„ Planted mushroom at %s â†’ entangled with ğŸŒ™ lunar node (moon phase)" % plot_id)
		_:
			print("ğŸŒ± Planted at %s" % plot_id)


## Growth

func grow(delta: float, conspiracy_network = null, territory_manager = null, icon_network = null) -> float:
	"""Evolve quantum state (theta drift, phi precession)

	NO classical growth - plants instant full size!
	This just manipulates quantum probability ratios.
	"""
	if not is_planted or not quantum_state:
		return 0.0

	# QUANTUM-ONLY: Just evolve theta (probability ratio) and phi (phase)
	# No energy accumulation, no classical growth!
	_evolve_quantum_state(delta, icon_network, conspiracy_network)

	return 0.0  # No energy growth to return


func _evolve_quantum_state(delta: float, icon_network = null, conspiracy_network = null):
	"""Quantum evolution using DualEmojiQubit.evolve() with Berry phase tracking

	NOTE: Icon quantum effects (Hamiltonian modulation) are applied centrally
	by FarmGrid._apply_icon_effects() to avoid duplication.

	PHYSICS: Theta (probability ratio) drifts based on entanglement and environment
	- Entangled: drift toward Ï€/2 (equal superposition, uncertain outcome)
	- Not entangled: drift toward 0 (north emoji, certain outcome)
	- Mushrooms + Sun: drift toward Ï€ (ğŸ‚ detritus) - sun regresses mushrooms
	- Measurement FREEZES theta (stops drift but phi continues)
	"""
	if not quantum_state:
		return

	# Azimuthal precession (phi evolution) - ALWAYS continues
	quantum_state.evolve(delta, 0.5)  # 0.5 = precession rate

	# Theta drift based on entanglement and environment - UNLESS MEASURED (frozen)
	if not theta_frozen:
		var target_theta = THETA_ISOLATED_TARGET if entangled_plots.is_empty() else THETA_ENTANGLED_TARGET

		# SPECIAL CASE: Mushrooms during sun phase regress to detritus
		# Sun pushes mushroom theta toward Ï€ (ğŸ‚ detritus)
		if plot_type == PlotType.MUSHROOM and conspiracy_network:
			if conspiracy_network.has_method("is_currently_sun") and conspiracy_network.is_currently_sun():
				target_theta = PI  # Sun regresses mushrooms â†’ detritus

		var drift_rate = THETA_DRIFT_RATE * delta
		quantum_state.theta = lerp(quantum_state.theta, target_theta, drift_rate)




## Measurement (Observer Effect)

func measure(icon_network = null) -> String:
	"""Measure the quantum state, collapses superposition

	Icon effects on measurement:
	- Imperium: Biases measurement toward classical states (ordered collapse)
	"""
	if has_been_measured or not quantum_state:
		return get_dominant_emoji()

	has_been_measured = true

	# Apply Imperium collapse bias BEFORE measurement (QUANTUM LAYER)
	if icon_network and icon_network.has("imperium") and icon_network.imperium:
		icon_network.imperium.apply_collapse_bias(quantum_state)

	# Use quantum state's built-in measurement (samples probability distribution)
	var final_state = quantum_state.measure()
	state_collapsed.emit(final_state)

	# PHYSICS: Measurement has THREE effects:

	# 1. FREEZES theta drift - probability ratio locked in
	theta_frozen = true
	print("â„ï¸ Theta frozen at %.2f rad (P(ğŸŒ¾)=%.0f%%, P(ğŸ‘¥)=%.0f%%)" %
		[quantum_state.theta,
		 quantum_state.get_north_probability() * 100,
		 quantum_state.get_south_probability() * 100])

	# 2. DETANGLES from other plots - pulls out of quantum space
	var num_entanglements = entangled_plots.size()
	if num_entanglements > 0:
		entangled_plots.clear()
		print("ğŸ”“ Detangled from %d plots (removed from quantum network)" % num_entanglements)

	# 3. CREATES conspiracy bond - classical correlation persists
	if conspiracy_node_id != "":
		conspiracy_bond_strength += 1.0
		print("ğŸ”— Measurement created bond: %s â†” [%s] (strength: %.1f)" %
			[plot_id, conspiracy_node_id, conspiracy_bond_strength])

	print("ğŸ‘ï¸ Measured %s -> %s" % [plot_id, final_state])
	return final_state


func get_dominant_emoji() -> String:
	"""Get the current dominant emoji based on quantum state"""
	if not quantum_state:
		var emojis = get_plot_emojis()
		return emojis["north"]  # Default to north emoji for plot type

	# Use quantum state's semantic representation
	return quantum_state.get_semantic_state()


func get_semantic_blend() -> float:
	"""Returns 0.0 (natural) to 1.0 (labor)"""
	if not quantum_state:
		return 0.5

	return quantum_state.get_semantic_blend()


## Harvesting

func harvest() -> Dictionary:
	"""Harvest measured plot - MUST measure first!

	Returns wheat if measured as ğŸŒ¾, returns people if measured as ğŸ‘¥
	"""
	if not is_planted or not quantum_state:
		return {"success": false, "yield": 0, "quality": 0.0, "outcome": ""}

	# MUST measure before harvest
	if not has_been_measured:
		print("âš ï¸ Cannot harvest unmeasured plot! Measure first to observe quantum state.")
		return {"success": false, "yield": 0, "quality": 0.0, "outcome": ""}

	# Get measurement outcome (what was measured as)
	var measured_state = get_dominant_emoji()
	var current_berry = quantum_state.get_berry_phase()
	var emojis = get_plot_emojis()

	var final_yield = 0
	var quality_multiplier = 1.0
	var outcome_type = ""

	if measured_state == emojis["north"]:  # North emoji (successful harvest)
		# Successful harvest of primary resource
		match plot_type:
			PlotType.WHEAT:
				outcome_type = "wheat"
			PlotType.TOMATO:
				outcome_type = "tomato"
			PlotType.MUSHROOM:
				outcome_type = "mushroom"
			_:
				outcome_type = "wheat"

		var base_yield = randi_range(10, 15)

		# Quality modifiers
		quality_multiplier = 1.0 - OBSERVER_PENALTY
		quality_multiplier += current_berry * 0.1

		final_yield = int(base_yield * quality_multiplier)
		print("âœ‚ï¸ Harvested %d %s from %s (quality: %.1f%%, berry: %.2f)" %
			[final_yield, outcome_type, plot_id, quality_multiplier * 100, current_berry])

	else:  # South emoji (processed form or labor)
		# Measured as secondary state
		match plot_type:
			PlotType.WHEAT:
				outcome_type = "labor"  # ğŸ‘¥ Labor
			PlotType.TOMATO:
				outcome_type = "sauce"  # ğŸ Sauce
			PlotType.MUSHROOM:
				outcome_type = "detritus"  # ğŸ‚ Detritus
			_:
				outcome_type = "labor"

		final_yield = 1  # Return 1 unit
		print("%s Measured as %s from %s" % [measured_state, outcome_type, plot_id])

	# Increment replant counter
	replant_cycles += 1

	# Reset plot for next cycle
	is_planted = false
	has_been_measured = false
	theta_frozen = false  # Un-freeze for next planting
	quantum_state = null  # Will be recreated on next plant()

	return {
		"success": true,
		"yield": final_yield,
		"quality": quality_multiplier,
		"outcome": outcome_type,  # "wheat" or "labor"
		"berry_phase": current_berry
	}


func reset():
	"""Reset plot to empty state (called after harvest)"""
	is_planted = false
	has_been_measured = false
	theta_frozen = false
	quantum_state = null  # Will be recreated on next plant()
	# Note: replant_cycles and berry_phase persist for stats


## Entanglement

func create_entanglement(other_plot_id: String, strength: float = 0.8):
	"""Create entanglement connection to another plot"""
	if entangled_plots.size() >= MAX_ENTANGLEMENTS:
		print("âš ï¸ Max entanglements reached for %s" % plot_id)
		return false

	if entangled_plots.has(other_plot_id):
		print("âš ï¸ Already entangled with %s" % other_plot_id)
		return false

	entangled_plots[other_plot_id] = strength
	print("ğŸ”— Entangled %s â†” %s (strength: %.2f)" % [plot_id, other_plot_id, strength])
	return true


func remove_entanglement(other_plot_id: String):
	"""Remove entanglement connection"""
	if entangled_plots.has(other_plot_id):
		entangled_plots.erase(other_plot_id)
		print("ğŸ”“ Disentangled %s â†” %s" % [plot_id, other_plot_id])


func get_entanglement_count() -> int:
	return entangled_plots.size()


## Quantum State Info

func get_bloch_vector() -> Vector3:
	"""Get Bloch sphere representation"""
	if not quantum_state:
		return Vector3(0, 0, 1)  # Default to north pole

	return quantum_state.get_bloch_vector()


func get_state_description() -> String:
	"""Get human-readable state description with dual emoji display"""
	if not is_planted:
		return "Empty"

	var stage = ""

	if has_been_measured:
		stage = "Measured"
		var emoji = get_dominant_emoji()
		return "%s %s" % [emoji, stage]
	elif theta_frozen:
		stage = "Frozen"
	elif abs(theta - PI/2.0) < 0.3:
		stage = "Superposed"
	elif theta < PI/4:
		stage = "Wheat-likely"
	else:
		stage = "Uncertain"

	# DUAL EMOJI DISPLAY: Show both states with probabilities for unmeasured plots
	if quantum_state:
		var emojis = get_plot_emojis()
		var north_emoji = emojis["north"]
		var south_emoji = emojis["south"]
		var north_prob = quantum_state.get_north_probability() * 100
		var south_prob = quantum_state.get_south_probability() * 100
		return "%s %.0f%% | %s %.0f%% - %s" % [north_emoji, north_prob, south_emoji, south_prob, stage]
	else:
		var emoji = get_dominant_emoji()
		return "%s %s" % [emoji, stage]


func get_cluster_size() -> int:
	"""Get number of qubits in cluster (0 if not in cluster)"""
	if quantum_state and quantum_state.is_in_cluster():
		return quantum_state.entangled_cluster.get_qubit_count()
	return 0


func get_cluster_state_type() -> String:
	"""Get cluster state type (GHZ, W, Cluster, or empty)"""
	if not quantum_state or not quantum_state.is_in_cluster():
		return ""

	var cluster = quantum_state.entangled_cluster
	if cluster.is_ghz_type():
		return "GHZ"
	elif cluster.is_w_type():
		return "W"
	elif cluster.is_cluster_type():
		return "Cluster"
	else:
		return "Custom"


func get_entanglement_description() -> String:
	"""Get human-readable entanglement description"""
	if quantum_state and quantum_state.is_in_cluster():
		var size = get_cluster_size()
		var state_type = get_cluster_state_type()
		return "%d-qubit %s cluster" % [size, state_type]
	elif quantum_state and quantum_state.is_in_pair():
		return "Bell pair (2-qubit)"
	else:
		return "Not entangled"


## Mill/Market Processing (Buildings)

# Mill processing state
var mill_processing_timer: float = 0.0
const MILL_PROCESS_INTERVAL: float = 5.0  # Process wheat every 5 seconds

# Market processing state
var market_processing_timer: float = 0.0
const MARKET_PROCESS_INTERVAL: float = 3.0  # Sell flour every 3 seconds


func process_mill(dt: float, farm_grid, farm_economy, conspiracy_network):
	"""Mill: Auto-convert adjacent wheat to flour"""
	if plot_type != PlotType.MILL:
		return

	mill_processing_timer += dt

	if mill_processing_timer >= MILL_PROCESS_INTERVAL:
		mill_processing_timer = 0.0

		# Check if we have wheat in inventory to process
		if farm_economy.wheat_inventory > 0:
			# Process 1 wheat â†’ 1 flour
			var wheat_to_process = min(1, farm_economy.wheat_inventory)

			# Entangle with 'sauce' conspiracy node (state transformation!)
			var processing_bonus = 1.0
			var node_energy = 0.0
			if conspiracy_network:
				conspiracy_node_id = "sauce"  # Mills transform wheat â†’ flour
				node_energy = conspiracy_network.get_node_energy("sauce")
				if node_energy > 0:
					# Higher energy = faster/better processing
					processing_bonus = 1.0 + (node_energy / 10.0)  # Up to +50% bonus

			var flour_output = int(wheat_to_process * processing_bonus)
			farm_economy.process_wheat_to_flour(wheat_to_process)

			# If bonus production, add extra flour
			if flour_output > wheat_to_process:
				farm_economy.add_flour(flour_output - wheat_to_process)
				print("ğŸ­ Mill bonus: +%d flour (sauce node energy: %.1f)" % [flour_output - wheat_to_process, node_energy])


func process_market(dt: float, farm_economy, conspiracy_network):
	"""Market: Auto-sell flour for credits with fluctuating prices"""
	if plot_type != PlotType.MARKET:
		return

	market_processing_timer += dt

	if market_processing_timer >= MARKET_PROCESS_INTERVAL:
		market_processing_timer = 0.0

		# Check if we have flour to sell
		if farm_economy.flour_inventory > 0:
			# Entangle with 'market' conspiracy node (value fluctuation!)
			var base_price = 5  # Base price per flour
			var market_price = base_price

			if conspiracy_network:
				conspiracy_node_id = "market"  # Markets set prices
				var market_node = conspiracy_network.nodes.get("market")
				if market_node:
					# Price fluctuates based on node theta (value superposition!)
					# theta = 0 (north) â†’ high prices
					# theta = Ï€ (south) â†’ low prices
					var theta_normalized = market_node.theta / PI
					var price_multiplier = 2.0 - theta_normalized  # 2.0x to 1.0x

					# Energy also affects price (more energy = better prices)
					var energy_bonus = 1.0 + (market_node.energy / 20.0)

					market_price = int(base_price * price_multiplier * energy_bonus)

			# Sell 1 flour for market price
			var flour_to_sell = min(1, farm_economy.flour_inventory)
			farm_economy.sell_flour(flour_to_sell, market_price)


## Debug

func get_debug_info() -> String:
	var stability_str = ""
	if quantum_state and quantum_state.berry_phase_enabled:
		var stability = quantum_state.get_cultural_stability()
		var berry = quantum_state.get_berry_phase_abs()
		stability_str = " | ğŸ“œ%.2f (Î³=%.2f)" % [stability, berry]

	var prob_wheat = quantum_state.get_north_probability() * 100 if quantum_state else 50.0
	return "[%s] %s | Î¸=%.2f Ï†=%.2f | P(ğŸŒ¾)=%.0f%% | Entangled: %d%s" % [
		plot_id,
		get_dominant_emoji(),
		theta,
		phi,
		prob_wheat,
		entangled_plots.size(),
		stability_str
	]


## Chaos Territory Events

func _trigger_chaos_bonus():
	"""Trigger a random Chaos bonus event (quantum mechanics)"""
	if not quantum_state:
		return

	var event_roll = randf()

	if event_roll < 0.33:
		# Shift theta toward wheat (increase certainty of good outcome)
		var old_theta = quantum_state.theta
		quantum_state.theta = max(0.0, quantum_state.theta - PI/4)
		print("ğŸ…âœ¨ Chaos bonus: %s theta shifted toward wheat! (%.2f â†’ %.2f rad)" %
			[plot_id, old_theta, quantum_state.theta])

	elif event_roll < 0.66:
		# Supercharge entanglement (shift to superposition for interesting outcomes)
		quantum_state.theta = PI / 2.0
		print("ğŸ…âš¡ Chaos bonus: %s forced into superposition! (Î¸ = Ï€/2)" % plot_id)

	else:
		# Free conspiracy activation (if tomato)
		if plot_type == PlotType.TOMATO:
			print("ğŸ…ğŸŒ€ Chaos bonus: Conspiracy energy surge!" % plot_id)
			# Conspiracy network will handle this


func _trigger_chaos_disaster():
	"""Trigger a random Chaos disaster event (quantum mechanics)"""
	if not quantum_state:
		return

	var event_roll = randf()

	if event_roll < 0.5:
		# Shift theta toward labor (increase chance of bad outcome)
		var old_theta = quantum_state.theta
		quantum_state.theta = min(PI, quantum_state.theta + PI/3)
		print("ğŸ…ğŸ’€ Chaos disaster: %s theta shifted toward labor! (%.2f â†’ %.2f rad)" %
			[plot_id, old_theta, quantum_state.theta])

	else:
		# Entanglement collapse
		if not entangled_plots.is_empty():
			print("ğŸ…ğŸ’¥ Chaos disaster: %s entanglements collapse!" % plot_id)
			entangled_plots.clear()
			if quantum_state and quantum_state.entangled_pair:
				quantum_state.entangled_pair = null
