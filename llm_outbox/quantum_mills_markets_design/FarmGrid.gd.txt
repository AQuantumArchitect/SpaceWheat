# NOTE: This is an experimental/archived version of FarmGrid. The active version is in Core/GameMechanics/
# Keeping this without class_name to avoid conflicts with the active FarmGrid
extends Node

## Farm Grid Manager
## Manages a grid of wheat plots and their interactions

signal plot_planted(position: Vector2i)
signal plot_harvested(position: Vector2i, yield_data: Dictionary)
signal entanglement_created(from: Vector2i, to: Vector2i)
signal entanglement_removed(from: Vector2i, to: Vector2i)

# Preload classes
const WheatPlot = preload("res://Core/GameMechanics/WheatPlot.gd")
const TopologyAnalyzer = preload("res://Core/QuantumSubstrate/TopologyAnalyzer.gd")
const EntangledPair = preload("res://Core/QuantumSubstrate/EntangledPair.gd")
const EntangledCluster = preload("res://Core/QuantumSubstrate/EntangledCluster.gd")

# Grid configuration
@export var grid_width: int = 5
@export var grid_height: int = 5

# Plot storage
var plots: Dictionary = {}  # Vector2i -> WheatPlot

# Entangled pairs (NEW - density matrix representation)
var entangled_pairs: Array = []  # Array of EntangledPair objects

# Entangled clusters (N-qubit states via sequential gates)
var entangled_clusters: Array = []  # Array of EntangledCluster objects

# Conspiracy network (for tomato growth)
var conspiracy_network = null

# Faction territory manager (for territorial effects)
var faction_territory_manager = null

# Farm economy (for mill/market processing)
var farm_economy = null

# Topology analyzer (for knot bonuses)
var topology_analyzer: TopologyAnalyzer

# Environmental parameters
var base_temperature: float = 20.0  # Base farm temperature (Kelvin or relative)
var active_icons: Array = []  # Array of LindbladIcon affecting the farm

# Stats
var total_plots_planted: int = 0
var total_wheat_harvested: int = 0


func _ready():
	print("ðŸŒ¾ FarmGrid initialized: %dx%d = %d plots" % [grid_width, grid_height, grid_width * grid_height])

	# Initialize topology analyzer
	topology_analyzer = TopologyAnalyzer.new()

	set_process(true)


func _process(delta):
	# Apply Icon effects to quantum states (Lindblad evolution)
	_apply_icon_effects(delta)

	# Apply decoherence to entangled pairs
	_apply_entangled_pair_decoherence(delta)

	# Build icon_network for growth modifiers (QUANTUM LAYER)
	var icon_network = _build_icon_network()

	# Grow all planted plots
	for position in plots.keys():
		var plot = plots[position]
		if plot.is_planted:
			plot.grow(delta, conspiracy_network, faction_territory_manager, icon_network)

	# Process mills and markets (buildings)
	if farm_economy:
		for position in plots.keys():
			var plot = plots[position]
			if plot.plot_type == WheatPlot.PlotType.MILL:
				plot.process_mill(delta, self, farm_economy, conspiracy_network)
			elif plot.plot_type == WheatPlot.PlotType.MARKET:
				plot.process_market(delta, farm_economy, conspiracy_network)


func _apply_icon_effects(delta: float):
	"""Apply Icon effects to all quantum states (Lindblad framework)"""
	if active_icons.is_empty():
		return

	# Calculate effective temperature from all Icons
	var effective_temp = base_temperature
	for icon in active_icons:
		if icon.active_strength > 0.0:
			effective_temp += icon.get_effective_temperature() - icon.base_temperature

	# Apply each Icon's quantum effects to single qubits
	for position in plots.keys():
		var plot = plots[position]
		if plot.is_planted and plot.quantum_state:
			# Set temperature
			plot.quantum_state.environment_temperature = effective_temp

			# Apply each Icon's Lindblad operators
			for icon in active_icons:
				icon.apply_to_qubit(plot.quantum_state, delta)

	# NOTE: Icons apply to individual qubits via apply_to_qubit() above
	# Entangled pairs automatically evolve via Lindblad operators on each qubit
	# No separate apply_to_entangled_pair() method needed

	# Apply Icon effects to entangled clusters (simplified - per-qubit decoherence)
	# Update at reduced rate (10 FPS instead of 60 FPS) for performance
	if Engine.get_frames_drawn() % 6 == 0:
		for cluster in entangled_clusters:
			for i in range(cluster.get_qubit_count()):
				var plot_id = cluster.qubit_ids[i]
				var plot = _get_plot_by_id(plot_id)
				if plot and plot.quantum_state:
					# Apply Icon effects to each qubit individually
					for icon in active_icons:
						icon.apply_to_qubit(plot.quantum_state, delta * 6)


func _apply_entangled_pair_decoherence(delta: float):
	"""Apply realistic decoherence to entangled pairs"""
	const Lindblad = preload("res://Core/QuantumSubstrate/LindbladEvolution.gd")

	for pair in entangled_pairs:
		# Get effective temperature
		var temp = base_temperature
		for icon in active_icons:
			if icon.active_strength > 0.0:
				temp = max(temp, icon.get_effective_temperature())

		# Apply decoherence via Lindblad equation
		pair.density_matrix = Lindblad.apply_two_qubit_decoherence_4x4(
			pair.density_matrix,
			delta,
			temp,
			pair.coherence_time_T1
		)


func _build_icon_network() -> Dictionary:
	"""Build icon_network dictionary from active_icons array

	Creates a lookup table for WheatPlot to access Icons by name
	for growth modifiers and measurement bias.

	Returns:
		Dictionary with keys: "biotic", "chaos", "imperium"
	"""
	var icon_network = {}

	for icon in active_icons:
		if icon.icon_emoji == "ðŸŒ¾":  # Biotic Flux
			icon_network["biotic"] = icon
		elif icon.icon_emoji == "ðŸ…":  # Chaos Vortex
			icon_network["chaos"] = icon
		elif icon.icon_emoji == "ðŸ°":  # Imperium/Carrion Throne
			icon_network["imperium"] = icon

	return icon_network


## Plot Management

func get_plot(position: Vector2i) -> WheatPlot:
	"""Get or create plot at position"""
	if not is_valid_position(position):
		return null

	if not plots.has(position):
		var plot = WheatPlot.new()
		plot.plot_id = "plot_%d_%d" % [position.x, position.y]
		plot.grid_position = position
		plots[position] = plot

		# Register with faction territory manager
		if faction_territory_manager:
			faction_territory_manager.register_plot(position)

	return plots[position]


func is_valid_position(position: Vector2i) -> bool:
	"""Check if position is within grid bounds"""
	return (position.x >= 0 and position.x < grid_width and
			position.y >= 0 and position.y < grid_height)


func _find_plot_by_id(plot_id: String) -> Vector2i:
	"""Find grid position of a plot by its ID"""
	for y in range(grid_height):
		for x in range(grid_width):
			var pos = Vector2i(x, y)
			var plot = get_plot(pos)
			if plot and plot.plot_id == plot_id:
				return pos
	return Vector2i(-1, -1)


func _get_plot_by_id(plot_id: String) -> WheatPlot:
	"""Get plot directly by ID (convenience wrapper for cluster operations)"""
	var pos = _find_plot_by_id(plot_id)
	if pos != Vector2i(-1, -1):
		return get_plot(pos)
	return null


func is_plot_empty(position: Vector2i) -> bool:
	"""Check if plot is empty (not planted)"""
	var plot = get_plot(position)
	return plot != null and not plot.is_planted


func is_plot_mature(position: Vector2i) -> bool:
	"""Check if plot has planted wheat (quantum-only: instant full size)"""
	var plot = get_plot(position)
	return plot != null and plot.is_planted


## Farming Operations

func plant_wheat(position: Vector2i) -> bool:
	"""Plant wheat at position"""
	var plot = get_plot(position)
	if plot == null or plot.is_planted:
		return false

	plot.plot_type = WheatPlot.PlotType.WHEAT
	plot.plant()
	total_plots_planted += 1
	plot_planted.emit(position)

	# AUTO-ENTANGLE: If this plot has infrastructure entanglements, entangle quantum states
	_auto_entangle_from_infrastructure(position)

	return true


func plant_tomato(position: Vector2i, conspiracy_network = null) -> bool:
	"""Plant tomato at position, connected to conspiracy network"""
	var plot = get_plot(position)
	if plot == null or plot.is_planted:
		return false

	plot.plot_type = WheatPlot.PlotType.TOMATO

	# Assign to a conspiracy node (cycle through the 12 nodes)
	var node_ids = ["seed", "observer", "underground", "genetic", "ripening", "market",
					"sauce", "identity", "solar", "water", "meaning", "meta"]
	var node_index = total_plots_planted % node_ids.size()
	plot.conspiracy_node_id = node_ids[node_index]

	plot.plant()
	total_plots_planted += 1
	plot_planted.emit(position)

	# AUTO-ENTANGLE: If this plot has infrastructure entanglements, entangle quantum states
	_auto_entangle_from_infrastructure(position)

	print("ðŸ… Planted tomato at %s connected to node: %s" % [plot.plot_id, plot.conspiracy_node_id])
	return true


func plant_mushroom(position: Vector2i) -> bool:
	"""Plant mushroom at position - absorbs energy during moon phase"""
	var plot = get_plot(position)
	if plot == null or plot.is_planted:
		return false

	plot.plot_type = WheatPlot.PlotType.MUSHROOM
	plot.plant()  # This will entangle with solar node automatically
	total_plots_planted += 1
	plot_planted.emit(position)

	# AUTO-ENTANGLE: If this plot has infrastructure entanglements, entangle quantum states
	_auto_entangle_from_infrastructure(position)

	return true


func place_mill(position: Vector2i) -> bool:
	"""Place mill building - converts wheat to flour"""
	var plot = get_plot(position)
	if plot == null or plot.is_planted:
		return false

	# Mark as occupied (buildings are instantly "mature")
	plot.plot_type = WheatPlot.PlotType.MILL
	plot.conspiracy_node_id = "sauce"  # Entangle with transformation node
	plot.is_planted = true
	# Quantum-only: No is_mature property (instant full size)
	plot_planted.emit(position)

	print("ðŸ­ Placed mill at %s â†’ entangled with ðŸ…â†’ðŸ sauce node (transformation)" % plot.plot_id)
	return true


func place_market(position: Vector2i) -> bool:
	"""Place market building - sells flour for credits"""
	var plot = get_plot(position)
	if plot == null or plot.is_planted:
		return false

	# Mark as occupied (buildings are instantly "mature")
	plot.plot_type = WheatPlot.PlotType.MARKET
	plot.conspiracy_node_id = "market"  # Entangle with market node
	plot.is_planted = true
	# Quantum-only: No is_mature property (instant full size)
	plot_planted.emit(position)

	print("ðŸ’° Placed market at %s â†’ entangled with ðŸ’°â†’ðŸ“ˆ market node (value fluctuation)" % plot.plot_id)
	return true


func harvest_wheat(position: Vector2i) -> Dictionary:
	"""Harvest wheat at position (quantum-only: must be planted)"""
	var plot = get_plot(position)
	if plot == null or not plot.is_planted:
		return {"success": false}

	var yield_data = plot.harvest()
	if yield_data["success"]:
		total_wheat_harvested += yield_data["yield"]

		# Add wheat to economy inventory
		if farm_economy:
			farm_economy.record_harvest(yield_data["yield"])

		plot_harvested.emit(position, yield_data)

	return yield_data


func get_local_network(center_plot: WheatPlot, radius: int = 2) -> Array:
	"""Get plots within entanglement distance from center plot

	Args:
		center_plot: The plot at the center of the local network
		radius: Number of entanglement hops to include

	Returns:
		Array of WheatPlot forming the local entanglement network
	"""
	if not center_plot or not center_plot.quantum_state:
		return [center_plot] if center_plot else []

	var local = [center_plot]
	var visited = {center_plot: true}
	var current_layer = [center_plot]

	for hop in range(radius):
		var next_layer = []
		for plot in current_layer:
			if not plot.is_planted:
				continue

			# Get entangled partners via WheatPlot.entangled_plots
			for partner_id in plot.entangled_plots.keys():
				var partner_pos = _find_plot_by_id(partner_id)
				if partner_pos != Vector2i(-1, -1):
					var partner_plot = get_plot(partner_pos)
					if partner_plot and not visited.has(partner_plot):
						local.append(partner_plot)
						next_layer.append(partner_plot)
						visited[partner_plot] = true

		current_layer = next_layer
		if current_layer.is_empty():
			break

	return local


func _find_plot_by_qubit(qubit) -> WheatPlot:
	"""Find plot containing a specific qubit"""
	for plot in plots.values():
		if plot.quantum_state == qubit:
			return plot
	return null


func harvest_with_topology(position: Vector2i, local_radius: int = 2) -> Dictionary:
	"""Harvest wheat with local topology bonus and coherence penalty

	This is the NEW harvest method that implements the quantum-classical divide:
	- Analyzes local entanglement topology for bonus
	- Applies coherence penalty (decoherence reduces yield)
	- Measures quantum state (collapses superposition)
	- Breaks entanglements (measurement destroys quantum state)

	Args:
		position: Grid position to harvest
		local_radius: Entanglement hops to include in local network (default 2)

	Returns:
		Dictionary with harvest results:
		{
			"success": bool,
			"yield": float,
			"base_yield": float,
			"state": String (ðŸŒ¾ or ðŸ‘¥),
			"state_bonus": float,
			"topology_bonus": float,
			"coherence": float,
			"pattern_name": String,
			"jones": float
		}
	"""
	var plot = get_plot(position)
	if plot == null or not plot.is_planted:
		return {"success": false}

	# 1. Get local entanglement network
	var local_plots = get_local_network(plot, local_radius)

	# 2. Analyze local topology
	var local_topology = topology_analyzer.analyze_entanglement_network(local_plots)

	# 3. Check coherence (decoherence reduces yield)
	var coherence = 1.0
	if plot.quantum_state:
		coherence = plot.quantum_state.get_coherence()

	# 4. Measure quantum state (collapse superposition)
	var measurement_result = ""
	if plot.quantum_state:
		# If part of entangled cluster, measure via cluster
		if plot.quantum_state.is_in_cluster():
			var cluster = plot.quantum_state.entangled_cluster
			var index = plot.quantum_state.cluster_qubit_index

			# Measure qubit in cluster (collapses entire cluster!)
			var outcome = cluster.measure_qubit(index)
			measurement_result = cluster.qubits[index].north_emoji if outcome == 0 else cluster.qubits[index].south_emoji

			# Handle cluster collapse
			_handle_cluster_collapse(cluster)

		# If part of entangled pair, measure via pair
		elif plot.quantum_state.entangled_pair != null:
			var pair = plot.quantum_state.entangled_pair
			var is_a = plot.quantum_state.is_qubit_a

			# Measure via pair (collapses density matrix)
			if is_a:
				measurement_result = pair.measure_qubit_a()
			else:
				measurement_result = pair.measure_qubit_b()

			# CRITICAL: Update partner qubit's Bloch sphere state to match collapsed density matrix
			var other_plot_id = pair.qubit_b_id if is_a else pair.qubit_a_id
			var other_pos = _find_plot_by_id(other_plot_id)
			if other_pos != Vector2i(-1, -1):
				var other_plot = get_plot(other_pos)
				if other_plot and other_plot.quantum_state:
					# Get the collapsed state from density matrix
					var rho_other = pair._partial_trace_a() if is_a else pair._partial_trace_b()

					# Update other qubit's Bloch sphere to match
					other_plot.quantum_state.from_density_matrix(rho_other)

					# Unlink from pair
					other_plot.quantum_state.entangled_pair = null

					print("  â†ª Cascade: Partner qubit %s collapsed to Î¸=%.2f" % [other_plot_id, other_plot.quantum_state.theta])

			# Remove pair from tracking (measurement breaks entanglement)
			if pair in entangled_pairs:
				entangled_pairs.erase(pair)

			# Unlink this qubit
			plot.quantum_state.entangled_pair = null
		else:
			# Single qubit measurement
			measurement_result = plot.quantum_state.measure()

	# 5. Calculate base yield from growth
	var growth_factor = plot.growth_progress  # 0.0 to 1.0
	var base_yield = 10.0 * growth_factor

	# 6. Quantum state modifier
	var state_modifier = 1.5 if measurement_result == "ðŸ‘¥" else 1.0

	# 7. Local topology bonus (parametric from Jones polynomial)
	var topology_bonus = local_topology.bonus_multiplier  # 1.0x to 3.0x

	# 8. Coherence penalty (decoherence reduces yield)
	var coherence_factor = coherence  # 0.0 to 1.0

	# 9. Faction territory value modifier
	var territory_value_modifier = 1.0
	if faction_territory_manager:
		var territory_effects = faction_territory_manager.get_territory_effects(position)
		if territory_effects.has("harvest_value_multiplier"):
			territory_value_modifier = territory_effects.harvest_value_multiplier

	# 10. Final yield calculation
	var final_yield = base_yield * state_modifier * topology_bonus * coherence_factor * territory_value_modifier

	# 10. Break entanglements (measurement destroys quantum state)
	# Clear WheatPlot entanglement tracking
	for partner_id in plot.entangled_plots.keys():
		var partner_pos = _find_plot_by_id(partner_id)
		if partner_pos != Vector2i(-1, -1):
			var partner_plot = get_plot(partner_pos)
			if partner_plot:
				partner_plot.entangled_plots.erase(plot.plot_id)
	plot.entangled_plots.clear()

	# Clear EntangledPair if exists
	if plot.quantum_state and plot.quantum_state.entangled_pair:
		var pair = plot.quantum_state.entangled_pair
		entangled_pairs.erase(pair)
		# Also clear partner's reference
		if plot.quantum_state.is_qubit_a and pair.qubit_b_id:
			var partner_pos = _find_plot_by_id(pair.qubit_b_id)
			if partner_pos != Vector2i(-1, -1):
				var partner = get_plot(partner_pos)
				if partner and partner.quantum_state:
					partner.quantum_state.entangled_pair = null
		elif not plot.quantum_state.is_qubit_a and pair.qubit_a_id:
			var partner_pos = _find_plot_by_id(pair.qubit_a_id)
			if partner_pos != Vector2i(-1, -1):
				var partner = get_plot(partner_pos)
				if partner and partner.quantum_state:
					partner.quantum_state.entangled_pair = null

	# 11. Reset plot
	plot.reset()

	# 12. Update stats
	total_wheat_harvested += int(final_yield)

	# 13. Emit signal with full data
	var yield_data = {
		"success": true,
		"yield": final_yield,
		"base_yield": base_yield,
		"state": measurement_result,
		"state_bonus": state_modifier,
		"topology_bonus": topology_bonus,
		"coherence": coherence,
		"coherence_penalty": coherence_factor,
		"pattern_name": local_topology.pattern.name,
		"jones": local_topology.features.jones_approximation,
		"protection": local_topology.pattern.protection_level,
		"glow_color": local_topology.pattern.glow_color
	}

	plot_harvested.emit(position, yield_data)

	return yield_data


func measure_plot(position: Vector2i) -> String:
	"""Measure quantum state (observer effect). Entanglement means measuring one collapses entire network!"""
	var plot = get_plot(position)
	if plot == null or not plot.is_planted:
		return ""

	# Build icon_network for Imperium collapse bias (QUANTUM LAYER)
	var icon_network = _build_icon_network()

	# Measure the primary plot (with Icon effects)
	var result = plot.measure(icon_network)

	# Spooky action at a distance: measure ALL plots in the entangled network!
	# Use flood-fill to find entire connected component
	var measured_ids = {plot.plot_id: true}
	var to_check = []

	# Add all direct partners to queue
	for entangled_id in plot.entangled_plots.keys():
		to_check.append(entangled_id)

	# Flood-fill through the entanglement network
	while not to_check.is_empty():
		var current_id = to_check.pop_front()

		# Skip if already measured
		if measured_ids.has(current_id):
			continue

		# Find and measure this plot
		var current_pos = _find_plot_by_id(current_id)
		if current_pos == Vector2i(-1, -1):
			continue

		var current_plot = get_plot(current_pos)
		if not current_plot or not current_plot.is_planted:
			continue

		# Measure it (with Icon effects)
		if not current_plot.has_been_measured:
			current_plot.measure(icon_network)
			print("  â†ª Entanglement network collapsed %s!" % current_id)

		measured_ids[current_id] = true

		# Add its entangled partners to the queue
		for next_id in current_plot.entangled_plots.keys():
			if not measured_ids.has(next_id):
				to_check.append(next_id)

	# MEASUREMENT COLLAPSES TO CLASSICAL STATE:
	# Break ALL entanglements for measured plots (quantum â†’ classical transition)
	# Measured plots become classical and no longer participate in quantum network
	for measured_id in measured_ids.keys():
		var measured_pos = _find_plot_by_id(measured_id)
		if measured_pos == Vector2i(-1, -1):
			continue

		var measured_plot = get_plot(measured_pos)
		if not measured_plot:
			continue

		# Clear all entanglements for this plot
		if not measured_plot.entangled_plots.is_empty():
			var num_broken = measured_plot.entangled_plots.size()
			measured_plot.entangled_plots.clear()
			print("  ðŸ”“ Measurement broke %d entanglements for %s (classical state)" % [num_broken, measured_id])

	# Also clean up density matrices for broken entangled pairs
	var pairs_to_remove = []
	for i in range(entangled_pairs.size()):
		var pair = entangled_pairs[i]
		var plot1 = _get_plot_by_id(pair.qubit_a_id)
		var plot2 = _get_plot_by_id(pair.qubit_b_id)

		# Remove pair if either plot has been measured
		if (plot1 and plot1.has_been_measured) or (plot2 and plot2.has_been_measured):
			pairs_to_remove.append(i)

	# Remove in reverse order to avoid index shifting
	pairs_to_remove.reverse()
	for i in pairs_to_remove:
		entangled_pairs.remove_at(i)

	return result


## Cluster Entanglement Helpers

func _update_cluster_gameplay_connections(cluster):
	"""Update WheatPlot.entangled_plots for all qubits in cluster (for topology)"""
	var plot_ids = cluster.get_all_plot_ids()

	# Each plot should be connected to all others in cluster
	for plot_id in plot_ids:
		var plot = _get_plot_by_id(plot_id)
		if not plot:
			continue

		# Clear old connections, rebuild from cluster
		plot.entangled_plots.clear()

		# Add all other plots in cluster
		for other_id in plot_ids:
			if other_id != plot_id:
				plot.entangled_plots[other_id] = 1.0  # Full strength


func _add_to_cluster(cluster, new_plot: WheatPlot, control_index: int) -> bool:
	"""Add new qubit to existing cluster via CNOT gate"""

	# Check cluster size limit (recommend 6-qubit max)
	if cluster.get_qubit_count() >= 6:
		print("âš ï¸ Cluster at max size (6 qubits)")
		return false

	# Add qubit to cluster with CNOT gate
	cluster.entangle_new_qubit_cnot(new_plot.quantum_state, new_plot.plot_id, control_index)

	# Link qubit to cluster
	new_plot.quantum_state.entangled_cluster = cluster
	new_plot.quantum_state.cluster_qubit_index = cluster.get_qubit_count() - 1

	# Update gameplay entanglement tracking (for topology)
	_update_cluster_gameplay_connections(cluster)

	print("ðŸ”— Added %s to cluster (size: %d)" % [new_plot.plot_id, cluster.get_qubit_count()])
	return true


func _upgrade_pair_to_cluster(pair, new_plot: WheatPlot) -> bool:
	"""Upgrade 2-qubit pair to 3-qubit cluster"""

	# Create new cluster
	var cluster = EntangledCluster.new()

	# Find the two plots in the pair
	var plot_a = _get_plot_by_id(pair.qubit_a_id)
	var plot_b = _get_plot_by_id(pair.qubit_b_id)

	if not plot_a or not plot_b:
		print("âš ï¸ Cannot find plots in pair")
		return false

	# Add both qubits to cluster
	cluster.add_qubit(plot_a.quantum_state, plot_a.plot_id)
	cluster.add_qubit(plot_b.quantum_state, plot_b.plot_id)

	# Create GHZ state (|00âŸ© + |11âŸ©) - equivalent to Bell state
	cluster.create_ghz_state()

	# Add third qubit via CNOT
	cluster.entangle_new_qubit_cnot(new_plot.quantum_state, new_plot.plot_id, 0)

	# Update qubit references
	plot_a.quantum_state.entangled_pair = null
	plot_a.quantum_state.entangled_cluster = cluster
	plot_a.quantum_state.cluster_qubit_index = 0

	plot_b.quantum_state.entangled_pair = null
	plot_b.quantum_state.entangled_cluster = cluster
	plot_b.quantum_state.cluster_qubit_index = 1

	new_plot.quantum_state.entangled_cluster = cluster
	new_plot.quantum_state.cluster_qubit_index = 2

	# Remove old pair, add cluster
	entangled_pairs.erase(pair)
	entangled_clusters.append(cluster)

	# Update gameplay connections
	_update_cluster_gameplay_connections(cluster)

	print("âœ¨ Upgraded pair to 3-qubit cluster: %s" % cluster.get_state_string())
	return true


func _handle_cluster_collapse(cluster):
	"""Handle measurement cascade when cluster is measured"""
	var plot_ids = cluster.get_all_plot_ids()

	# Update all qubits from collapsed cluster state
	for i in range(cluster.get_qubit_count()):
		var plot_id = plot_ids[i]
		var plot = _get_plot_by_id(plot_id)
		if not plot:
			continue

		# Get reduced density matrix for this qubit (partial trace)
		# For now: simplified - cluster measurement collapses to product state
		# Qubits become separable after measurement

		# Clear cluster reference
		plot.quantum_state.entangled_cluster = null
		plot.quantum_state.cluster_qubit_index = -1

		# Clear gameplay connections
		plot.entangled_plots.clear()

	# Remove cluster from tracking
	entangled_clusters.erase(cluster)

	print("ðŸ’¥ Cluster collapsed - %d qubits now separable" % plot_ids.size())


## Entanglement (Density Matrix System)

func _auto_entangle_from_infrastructure(position: Vector2i):
	"""Auto-entangle quantum states when planting in infrastructurally entangled plot"""
	var plot = get_plot(position)
	if not plot or not plot.is_planted:
		return

	# Check all infrastructure entanglement links
	for partner_pos in plot.plot_infrastructure_entanglements:
		var partner_plot = get_plot(partner_pos)

		# If partner is planted, entangle their quantum states
		if partner_plot and partner_plot.is_planted:
			# Check if already entangled (avoid duplicates)
			if not plot.entangled_plots.has(partner_plot.plot_id):
				# Recursively call create_entanglement to set up quantum state entanglement
				# This will skip the infrastructure setup (already done) and go straight to quantum entanglement
				_create_quantum_entanglement(position, partner_pos)
				print("  âš¡ Auto-entangled %s â†” %s (infrastructure activated)" % [position, partner_pos])


func _create_quantum_entanglement(pos_a: Vector2i, pos_b: Vector2i, bell_type: String = "phi_plus") -> bool:
	"""Create quantum state entanglement (internal helper)"""
	var plot_a = get_plot(pos_a)
	var plot_b = get_plot(pos_b)

	if not plot_a or not plot_b or not plot_a.is_planted or not plot_b.is_planted:
		return false

	# Smart entanglement logic: Cluster upgrade system (existing code)
	# Case 1: Plot A in cluster â†’ Add B to cluster
	if plot_a.quantum_state.is_in_cluster():
		return _add_to_cluster(
			plot_a.quantum_state.entangled_cluster,
			plot_b,
			plot_a.quantum_state.cluster_qubit_index
		)

	# Case 2: Plot B in cluster â†’ Add A to cluster
	if plot_b.quantum_state.is_in_cluster():
		return _add_to_cluster(
			plot_b.quantum_state.entangled_cluster,
			plot_a,
			plot_b.quantum_state.cluster_qubit_index
		)

	# Case 3: Plot A in pair â†’ Upgrade to cluster
	if plot_a.quantum_state.is_in_pair():
		return _upgrade_pair_to_cluster(plot_a.quantum_state.entangled_pair, plot_b)

	# Case 4: Plot B in pair â†’ Upgrade to cluster
	if plot_b.quantum_state.is_in_pair():
		return _upgrade_pair_to_cluster(plot_b.quantum_state.entangled_pair, plot_a)

	# Case 5: Neither entangled â†’ Create new EntangledPair
	var pair = EntangledPair.new()
	pair.qubit_a_id = plot_a.plot_id
	pair.qubit_b_id = plot_b.plot_id
	pair.north_emoji_a = plot_a.quantum_state.north_emoji
	pair.south_emoji_a = plot_a.quantum_state.south_emoji
	pair.north_emoji_b = plot_b.quantum_state.north_emoji
	pair.south_emoji_b = plot_b.quantum_state.south_emoji

	# Create Bell state
	match bell_type:
		"phi_plus": pair.create_bell_phi_plus()
		"phi_minus": pair.create_bell_phi_minus()
		"psi_plus": pair.create_bell_psi_plus()
		"psi_minus": pair.create_bell_psi_minus()
		_: pair.create_bell_phi_plus()

	# Link qubits to pair
	plot_a.quantum_state.entangled_pair = pair
	plot_a.quantum_state.is_qubit_a = true
	plot_b.quantum_state.entangled_pair = pair
	plot_b.quantum_state.is_qubit_a = false

	# Add to pairs array
	entangled_pairs.append(pair)

	# Update gameplay entanglement tracking
	plot_a.create_entanglement(plot_b.plot_id, 1.0)
	plot_b.create_entanglement(plot_a.plot_id, 1.0)

	return true


func create_entanglement(pos_a: Vector2i, pos_b: Vector2i, bell_type: String = "phi_plus") -> bool:
	"""Create entanglement between two plots (PLOT INFRASTRUCTURE MODEL)

	NEW: Entanglement is plot-level infrastructure (like gates)
	- Plots remember entanglement links even after harvest/replant
	- When planting in an entangled plot, quantum states auto-entangle

	Args:
		pos_a: Position of first plot
		pos_b: Position of second plot
		bell_type: Type of Bell state (used when both plots are planted)

	Returns:
		true if entanglement infrastructure created successfully
	"""
	if not is_valid_position(pos_a) or not is_valid_position(pos_b):
		return false

	if pos_a == pos_b:
		return false

	var plot_a = get_plot(pos_a)
	var plot_b = get_plot(pos_b)

	if plot_a == null or plot_b == null:
		return false

	# NEW: Set up plot infrastructure FIRST (works even if not planted)
	if not plot_a.plot_infrastructure_entanglements.has(pos_b):
		plot_a.plot_infrastructure_entanglements.append(pos_b)
		print("ðŸ—ï¸ Plot infrastructure: %s â†” %s (entanglement gate installed)" % [pos_a, pos_b])

	if not plot_b.plot_infrastructure_entanglements.has(pos_a):
		plot_b.plot_infrastructure_entanglements.append(pos_a)

	# If both plots are NOT planted, just set up infrastructure and return
	if not plot_a.is_planted or not plot_b.is_planted:
		print("  â†’ Infrastructure ready. Quantum entanglement will auto-activate when both plots are planted.")
		entanglement_created.emit(pos_a, pos_b)
		return true  # Infrastructure created successfully

	# Both plots are planted â†’ Create quantum entanglement using helper
	var success = _create_quantum_entanglement(pos_a, pos_b, bell_type)
	if success:
		entanglement_created.emit(pos_a, pos_b)
	return success


func remove_entanglement(pos_a: Vector2i, pos_b: Vector2i):
	"""Remove entanglement between two plots"""
	var plot_a = get_plot(pos_a)
	var plot_b = get_plot(pos_b)

	# Find and remove EntangledPair if it exists
	if plot_a and plot_a.quantum_state.entangled_pair != null:
		var pair = plot_a.quantum_state.entangled_pair
		if pair in entangled_pairs:
			entangled_pairs.erase(pair)

		# Unlink from both qubits
		if plot_a:
			plot_a.quantum_state.entangled_pair = null
		if plot_b:
			plot_b.quantum_state.entangled_pair = null

	# Also remove legacy entanglement tracking
	if plot_a:
		plot_a.remove_entanglement(plot_b.plot_id if plot_b else "")
	if plot_b:
		plot_b.remove_entanglement(plot_a.plot_id if plot_a else "")

	entanglement_removed.emit(pos_a, pos_b)


func are_plots_entangled(pos_a: Vector2i, pos_b: Vector2i) -> bool:
	"""Check if two plots are entangled"""
	var plot_a = get_plot(pos_a)
	var plot_b = get_plot(pos_b)

	if plot_a == null or plot_b == null:
		return false

	return plot_a.entangled_plots.has(plot_b.plot_id)


## Icon Management

func add_icon(icon) -> void:
	"""Add Icon to farm for quantum effects"""
	if icon not in active_icons:
		active_icons.append(icon)
		print("âœ¨ Added Icon to farm: %s" % icon.icon_name)


func remove_icon(icon) -> void:
	"""Remove Icon from farm"""
	if icon in active_icons:
		active_icons.erase(icon)
		print("ðŸš« Removed Icon from farm: %s" % icon.icon_name)


func get_effective_temperature() -> float:
	"""Get effective farm temperature from base + all Icons"""
	var temp = base_temperature
	for icon in active_icons:
		if icon.active_strength > 0.0:
			temp += icon.get_effective_temperature() - icon.base_temperature
	return temp


## Utility

func get_neighbors(position: Vector2i) -> Array[Vector2i]:
	"""Get valid neighbor positions (4-directional)"""
	var neighbors: Array[Vector2i] = []

	var directions = [
		Vector2i(0, -1),  # Up
		Vector2i(1, 0),   # Right
		Vector2i(0, 1),   # Down
		Vector2i(-1, 0)   # Left
	]

	for dir in directions:
		var neighbor_pos = position + dir
		if is_valid_position(neighbor_pos):
			neighbors.append(neighbor_pos)

	return neighbors


func get_all_planted_positions() -> Array[Vector2i]:
	"""Get positions of all planted plots"""
	var planted: Array[Vector2i] = []
	for position in plots.keys():
		if plots[position].is_planted:
			planted.append(position)
	return planted


func get_all_mature_positions() -> Array[Vector2i]:
	"""Get positions of all mature plots"""
	var mature: Array[Vector2i] = []
	for position in plots.keys():
		if plots[position].is_planted:  # Quantum-only: all planted plots are "mature"
			mature.append(position)
	return mature


func get_grid_stats() -> Dictionary:
	"""Get current grid statistics"""
	var planted_count = 0
	var mature_count = 0
	var entanglement_count = 0

	for plot in plots.values():
		if plot.is_planted:
			planted_count += 1
			mature_count += 1  # Quantum-only: all planted = mature
		entanglement_count += plot.get_entanglement_count()

	# Each entanglement is counted twice (bidirectional)
	entanglement_count /= 2

	return {
		"total_plots": plots.size(),
		"planted": planted_count,
		"mature": mature_count,
		"entanglements": entanglement_count,
		"total_harvested": total_wheat_harvested
	}


## Debug

func print_grid_state():
	"""Debug: Print current grid state"""
	print("\n=== FARM GRID STATE ===")
	var stats = get_grid_stats()
	print("Plots: %d | Planted: %d | Mature: %d | Entangled: %d" % [
		stats["total_plots"],
		stats["planted"],
		stats["mature"],
		stats["entanglements"]
	])
	print("Total Harvested: %d wheat" % total_wheat_harvested)

	for y in range(grid_height):
		var row = ""
		for x in range(grid_width):
			var pos = Vector2i(x, y)
			var plot = plots.get(pos)

			if plot == null or not plot.is_planted:
				row += "[ ]"
			else:
				# Quantum-only: all planted plots shown as [M]
				row += "[M]"

		print(row)

	print("======================\n")
