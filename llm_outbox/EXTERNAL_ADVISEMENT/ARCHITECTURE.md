# SpaceWheat Architecture - For External Advisement

**Purpose**: Understand how tools are structured and integrated without needing full source code

---

## High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         INPUT LAYER (Keyboard/UI)           â”‚
â”‚  - InputController (detects Q/E/R presses)  â”‚
â”‚  - 6 Tools: numbered 1-6                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ROUTING LAYER (ToolConfig)             â”‚
â”‚  - Maps Tool N + Key â†’ Action name           â”‚
â”‚  - Stores action definitions (labels, UI)   â”‚
â”‚  - Generates dynamic submenus                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     ACTION HANDLER LAYER                    â”‚
â”‚  - FarmInputHandler receives routed action  â”‚
â”‚  - Calls appropriate _action_*() method     â”‚
â”‚  - Validates plot selection                 â”‚
â”‚  - Emits action_performed signal            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      GAME LOGIC LAYER (Farm)                â”‚
â”‚  - Farm.build() - plant crops               â”‚
â”‚  - Farm.entangle_plots() - quantum ops      â”‚
â”‚  - Farm.measure_plot() - measurement        â”‚
â”‚  - Farm.harvest_plot() - resource generationâ”‚
â”‚  - Farm.grid.biomes - biome management      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      QUANTUM LAYER                          â”‚
â”‚  - BiomeBase (base class for biomes)        â”‚
â”‚  - QuantumBath (Lindblad evolution)         â”‚
â”‚  - DualEmojiQubit (2D projection)           â”‚
â”‚  - ComplexMatrix (density matrix math)      â”‚
â”‚  - Icon (emoji properties)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Tool Architecture

### Tool Structure

Each tool has:
- **Q Action**: Usually a submenu or primary action
- **E Action**: Secondary action or second submenu
- **R Action**: Tertiary action or special operation

### Submenu System

**Static Submenus** (Fixed options):
```
Submenu Name: "plant"
â”œâ”€ Q: plant_wheat
â”œâ”€ E: plant_mushroom
â””â”€ R: plant_tomato

These are hardcoded in ToolConfig.SUBMENUS
```

**Dynamic Submenus** (Generate at runtime):
```
Submenu Name: "energy_tap"
â”œâ”€ Q: tap_[first_discovered_emoji]
â”œâ”€ E: tap_[second_discovered_emoji]
â””â”€ R: tap_[third_discovered_emoji]

Generated by ToolConfig.get_dynamic_submenu("energy_tap", farm)
Reads from discovered vocabulary or registered biomes
```

### Signal Flow

```
User presses "Q" (action key)
    â†“
InputController detects key press
    â†“
InputController emits signal (e.g., "grower_tool_q")
    â†“
FarmView receives signal
    â†“
FarmInputHandler receives signal (via FarmView connection)
    â†“
FarmInputHandler._on_tool_q_pressed()
    â†“
Looks up action: ToolConfig.get_action(current_tool, "Q")
    â†“
Routes to FarmInputHandler._action_*(selected_plots)
    â†“
Action method calls Farm.* methods
    â†“
Farm updates game state
    â†“
FarmInputHandler emits action_performed signal
    â†“
UI updates (ResourcePanel, GridDisplay, etc.)
```

---

## Key Classes & Responsibilities

### InputController
- **Purpose**: Detect user input (keyboard keys)
- **Emits signals**:
  - `grower_tool_q / _e / _r` (Tool 1)
  - `quantum_tool_q / _e / _r` (Tool 2)
  - etc.
- **Signal format**: No parameters, just detection

### ToolConfig
- **Purpose**: Single source of truth for tool definitions
- **Stores**:
  - `TOOL_ACTIONS[1-6]` - Q/E/R definitions
  - `SUBMENUS` - Submenu definitions
- **Methods**:
  - `get_action(tool_num, key)` - returns action dict
  - `get_dynamic_submenu(name, farm)` - generates at runtime
  - `get_tool_name(tool_num)` - UI display

### FarmInputHandler
- **Purpose**: Route actions to game logic
- **Structure**:
  - Receives signal (e.g., "grower_tool_q")
  - Calls `_route_tool_action(tool_num, "Q")`
  - Looks up action name from ToolConfig
  - Calls matching `_action_*()` method
- **Action methods**:
  - `_action_plant_wheat(plots)` - Plant action
  - `_action_entangle_batch(plots)` - Entangle action
  - etc.

### Farm (Main Game Logic)
- **Purpose**: Hold game state, implement core mechanics
- **Key methods**:
  - `build(pos, crop_type)` - Plant a crop
  - `entangle_plots(pos1, pos2)` - Create Bell state
  - `measure_plot(pos)` - Measure quantum state
  - `harvest_plot(pos)` - Harvest and get yield
  - **Properties**:
    - `farm.grid` - FarmGrid (all plots)
    - `farm.economy` - Resource tracking
    - `farm.grid.biomes` - Dictionary of biomes

### FarmGrid
- **Purpose**: Manage 12 plots and 4 biomes
- **Structure**:
  - `grid_width = 6`, `grid_height = 2` (6Ã—2 grid)
  - `plots[pos]` - Array of BasePlot objects
  - `biomes[biome_name]` - Dictionary of BiomeBase objects
  - `plot_biome_assignments[pos]` - Which biome owns each plot
- **Key methods**:
  - `get_plot(pos)` - Return BasePlot at position
  - `are_plots_entangled(pos1, pos2)` - Check entanglement

### BiomeBase (Biome Classes)
- **4 instances**: BioticFlux, Market, Forest, Kitchen
- **Each has**:
  - `quantum_bath` - QuantumBath (Lindblad evolution)
  - `producible_emojis` - Which resources this biome makes
  - `measure_plot_in_biome(pos)` - Custom measurement
  - **New methods (Phase 4)**:
    - `pump_emoji(from, to, rate, duration)` - Pump population
    - `apply_reset(alpha, ref_state)` - Reset state

### QuantumBath
- **Purpose**: Manage quantum evolution for one biome
- **Structure**:
  - `_density_matrix` - ComplexMatrix (NÃ—N, N = # emojis)
  - `emoji_list` - Array of emoji strings
  - `active_icons` - Icon instances (Lindblad operators)
- **Key methods**:
  - `initialize_with_emojis(emojis)` - Set up bath
  - `inject_emoji(emoji, icon, amplitude)` - Add new emoji (Phase 1)
  - `evolve(timestep)` - Apply Lindblad dynamics
  - `measure_axis_costed(north, south, max_cost)` - Measure with cost (Phase 3)
  - `get_probability(emoji)` - Get population
  - `get_coherence(emoji1, emoji2)` - Get entanglement

### BasePlot
- **Purpose**: Represent one farm plot
- **Properties**:
  - `is_planted` - boolean
  - `has_been_measured` - boolean
  - `quantum_state` - DualEmojiQubit (2D projection)
  - `crop_type` - "wheat" / "mushroom" / "tomato"
- **Methods**:
  - `plant(biome, crop_type)` - Initialize quantum state
  - `measure()` - Collapse to measured state
  - `harvest()` - Return yield dict

### DualEmojiQubit
- **Purpose**: 2D quantum projection (north â†” south)
- **Properties**:
  - `north_emoji` - Basis state emoji
  - `south_emoji` - Basis state emoji
  - `purity` - Tr(ÏÂ²) of 2D subspace
  - `theta` - Rotation angle between basis states
- **Methods**:
  - `get_mass()` - Population in subspace
  - `get_order()` - Coherence visibility
  - `collapse(outcome)` - Project to outcome

---

## Tool Integration Pattern

Each tool follows this pattern:

### 1. Define in ToolConfig
```
Tool 1: {
  "Q": {"action": "submenu_plant", ...},
  "E": {"action": "entangle_batch", ...},
  "R": {"action": "measure_and_harvest", ...}
}
```

### 2. Define Submenus (if Q/E/R link to submenu)
```
"plant": {
  "Q": {"action": "plant_wheat", ...},
  "E": {"action": "plant_mushroom", ...},
  "R": {"action": "plant_tomato", ...}
}
```

### 3. Implement Handlers in FarmInputHandler
```
func _action_plant_wheat(plots: Array[Vector2i]):
    # Implementation
```

### 4. Wire Signal in FarmView
```
input_controller.grower_tool_q.connect(...)
```

---

## Farm Grid Layout

```
  0     1     2     3     4     5
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ M00 â”‚ M01 â”‚ B02 â”‚ B03 â”‚ B04 â”‚ B05 â”‚ Row 0
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
â”‚ F10 â”‚ F11 â”‚ F12 â”‚ F13 â”‚ K14 â”‚ K15 â”‚ Row 1
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

M = Market (ğŸ’°)
B = BioticFlux (ğŸŒ¾)
F = Forest (ğŸŒ)
K = Kitchen (ğŸ³)

Vector2i(x, y) = plot at column x, row y
Example: Vector2i(2, 0) = BioticFlux plot
```

---

## Resource Economy

### Resources Tracked
- **ğŸŒ¾ Wheat**: 500 starting (farming currency)
- **ğŸ‘¥ Labor**: 10 starting (workforce)
- **ğŸ„ Mushroom**: 10 starting (alternative crop)
- **ğŸ… Tomato**: 0 starting (discovered late game)
- **ğŸ’° Credits**: 1 starting (general currency)

### Accessed Via
```
farm.economy.get_resource("ğŸŒ¾")  # Returns count
farm.economy.spend_resource("ğŸŒ¾", amount)
farm.economy.gain_resource("ğŸŒ¾", amount)
```

---

## Quantum State in Gameplay

### Per-Plot State
Each planted plot has:
- `quantum_state: DualEmojiQubit` - 2D projection
- `quantum_state.bath: QuantumBath` - Reference to biome's bath

### Per-Biome State
Each biome has:
- `quantum_bath: QuantumBath` - Full N-dimensional state
- Evolves continuously via Lindblad master equation

### State Evolution
```
Frame 0: Plot planted
  â†’ Create 2D projection in biome's bath
  â†’ Initialize to |0âŸ© + |1âŸ© superposition (Î¸=Ï€/4)

Frames 1-N: Game runs
  â†’ Each frame: quantum_bath.evolve(delta_time)
  â†’ Lindblad evolution affects all emojis
  â†’ DualEmojiQubit projects out north_emoji â†” south_emoji
  â†’ Purity changes based on decoherence

Measurement:
  â†’ Plot.measure() collapses to outcome emoji
  â†’ Outcome probability based on purity
  â†’ Transitions plot from unmeasured â†’ measured

Harvest:
  â†’ Plot.harvest() generates yield
  â†’ Yield = base * purity_multiplier * (1.0/measurement_cost)?
  â†’ Resources added to farm.economy
```

---

## Why This Architecture Matters

### For Developers
- **Separation of concerns**: Input â†’ Routing â†’ Actions â†’ Logic â†’ Physics
- **Reusability**: Quantum system independent of tools
- **Testability**: Each layer can be tested independently

### For Designers
- **Easy to add tools**: Just add to ToolConfig + FarmInputHandler
- **Easy to modify**: ToolConfig is single source of truth
- **Dynamic content**: Submenus generate from game state

### For Balance
- **Easy to tune**: Change costs in ToolConfig
- **Easy to add features**: New biome = new bath, new dynamic submenu option

---

## File Structure

```
Core/
â”œâ”€â”€ Farm.gd - Main game logic
â”œâ”€â”€ GameMechanics/
â”‚   â”œâ”€â”€ FarmGrid.gd - Grid management
â”‚   â”œâ”€â”€ BasePlot.gd - Individual plot
â”‚   â””â”€â”€ FarmEconomy.gd - Resources
â”œâ”€â”€ GameState/
â”‚   â”œâ”€â”€ ToolConfig.gd - Tool definitions (CRITICAL)
â”‚   â””â”€â”€ QuantumRigorConfig.gd - Quantum modes
â”œâ”€â”€ Environment/
â”‚   â”œâ”€â”€ BiomeBase.gd - Biome base class
â”‚   â”œâ”€â”€ BioticFlux.gd - Wheat biome
â”‚   â”œâ”€â”€ Market.gd - Trading biome
â”‚   â”œâ”€â”€ Forest.gd - Ecology biome
â”‚   â””â”€â”€ Kitchen.gd - Bread biome
â””â”€â”€ QuantumSubstrate/
    â”œâ”€â”€ QuantumBath.gd - Lindblad evolution
    â”œâ”€â”€ DualEmojiQubit.gd - 2D projection
    â”œâ”€â”€ Icon.gd - Emoji properties
    â””â”€â”€ ComplexMatrix.gd - Math library

UI/
â”œâ”€â”€ FarmInputHandler.gd - Action routing (CRITICAL)
â”œâ”€â”€ PlayerShell.gd - Main UI container
â””â”€â”€ Panels/
    â”œâ”€â”€ ResourcePanel.gd - Show resources
    â”œâ”€â”€ PlotGridDisplay.gd - Show grid
    â””â”€â”€ ToolSelectionRow.gd - Show tools

Tests/
â”œâ”€â”€ test_all_tools_interactive.gd - Tool testing
â”œâ”€â”€ claude_plays_manual.gd - 100-turn gameplay
â””â”€â”€ test_harvest_*.gd - Specific mechanic tests
```

---

## For External Advisors

When reviewing design decisions:
1. **Check Tool Integration Pattern** - Can the design fit this structure?
2. **Check Farm.* API** - What new methods need implementation?
3. **Check Signal Flow** - How does new feature route through layers?
4. **Check Quantum System** - Does it respect QuantumBath invariants?
5. **Check Game Loop** - Is there a 100-turn playtest for verification?

