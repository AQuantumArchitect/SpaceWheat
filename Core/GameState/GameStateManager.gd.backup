extends Node

## GameStateManager - Singleton for save/load operations
## Handles 3 save slots, scenarios, and state capture/restore

const GameState = preload("res://Core/GameState/GameState.gd")
const VocabularyEvolution = preload("res://Core/QuantumSubstrate/VocabularyEvolution.gd")

# Save configuration
const SAVE_DIR = "user://saves/"
const NUM_SAVE_SLOTS = 3
const SCENARIO_DIR = "res://Scenarios/"

# Current state
var current_state: GameState = null
var current_scenario_id: String = "default"
var last_saved_slot: int = -1  # Track most recent save for "Reload Last Save"

# Reference to active game (set by FarmView)
var active_farm_view = null  # DEPRECATED: Use active_farm instead

# Direct reference to Farm simulation (Phase 1: Simulation-only saves)
var active_farm = null

# PERSISTENT VOCABULARY EVOLUTION - Travels with player across farms/biomes
var vocabulary_evolution: VocabularyEvolution = null


func _ready():
	# Ensure save directory exists
	var dir = DirAccess.open("user://")
	if not dir.dir_exists("saves"):
		dir.make_dir("saves")
	print("ðŸ’¾ GameStateManager ready - Save dir: " + SAVE_DIR)

	# Initialize persistent vocabulary evolution system
	if not vocabulary_evolution:
		vocabulary_evolution = VocabularyEvolution.new()
		vocabulary_evolution._ready()
		add_child(vocabulary_evolution)
		print("   ðŸ“š Persistent VocabularyEvolution initialized")


## New Game / Scenarios

func new_game(scenario_id: String = "default") -> GameState:
	"""Start new game by loading a scenario template"""
	print("ðŸŽ® Starting new game with scenario: " + scenario_id)
	current_scenario_id = scenario_id
	
	# Try to load scenario file, fall back to default state
	var scenario_path = SCENARIO_DIR + scenario_id + ".tres"
	if ResourceLoader.exists(scenario_path):
		current_state = ResourceLoader.load(scenario_path).duplicate()
		print("âœ“ Loaded scenario from: " + scenario_path)
	else:
		print("âš  Scenario not found, using default state")
		current_state = GameState.new()
		current_state.scenario_id = scenario_id
	
	current_state.save_timestamp = Time.get_unix_time_from_system()
	current_state.game_time = 0.0
	return current_state


## Save Operations

func save_game(slot: int) -> bool:
	"""Save current game state to slot (0-2)"""
	if slot < 0 or slot >= NUM_SAVE_SLOTS:
		push_error("Invalid save slot: " + str(slot))
		return false
	
	if not active_farm:
		push_error("No active game to save!")
		return false
	
	# Capture current state from live game
	var state = capture_state_from_game()
	
	# Save to disk
	var path = get_save_path(slot)
	var result = ResourceSaver.save(state, path)
	
	if result == OK:
		last_saved_slot = slot
		print("ðŸ’¾ Game saved to slot " + str(slot + 1) + ": " + path)
		return true
	else:
		push_error("Failed to save game to slot " + str(slot))
		return false


func get_save_path(slot: int) -> String:
	"""Get file path for save slot"""
	return SAVE_DIR + "save_slot_" + str(slot) + ".tres"


func save_exists(slot: int) -> bool:
	"""Check if save file exists in slot"""
	return FileAccess.file_exists(get_save_path(slot))


func get_save_info(slot: int) -> Dictionary:
	"""Get save file info for display in load menu"""
	if not save_exists(slot):
		return {"exists": false, "slot": slot}
	
	var state = load_game_state(slot)
	if not state:
		return {"exists": false, "slot": slot}
	
	return {
		"exists": true,
		"slot": slot,
		"display_name": state.get_save_display_name(),
		"scenario": state.scenario_id,
		"credits": state.credits,
		"goal_index": state.current_goal_index,
		"playtime": state.game_time
	}


## Load Operations

func load_game_state(slot: int) -> GameState:
	"""Load game state from slot (returns state, doesn't apply it)"""
	if slot < 0 or slot >= NUM_SAVE_SLOTS:
		push_error("Invalid save slot: " + str(slot))
		return null
	
	var path = get_save_path(slot)
	if not FileAccess.file_exists(path):
		print("âš  No save file in slot " + str(slot + 1))
		return null
	
	var state = ResourceLoader.load(path)
	if state:
		print("ðŸ“‚ Loaded save from slot " + str(slot + 1))
		return state
	else:
		push_error("Failed to load save from slot " + str(slot))
		return null


func load_and_apply(slot: int) -> bool:
	"""Load game state from slot and apply it to active game"""
	var state = load_game_state(slot)
	if not state:
		return false

	if not active_farm:
		push_error("No active game to apply state to!")
		return false

	apply_state_to_game(state)
	current_state = state
	current_scenario_id = state.scenario_id
	# NOTE: Don't update last_saved_slot here - only update on actual save
	# This ensures "Reload Last Save" reloads the last SAVED file, not last LOADED file
	return true


func reload_last_save() -> bool:
	"""Reload the most recently saved game by scanning all slots for latest timestamp"""
	var latest_slot = -1
	var latest_timestamp = 0.0

	# Scan all save slots to find the most recent
	for slot in range(NUM_SAVE_SLOTS):
		if not save_exists(slot):
			continue

		var state = load_game_state(slot)
		if state and state.save_timestamp > latest_timestamp:
			latest_timestamp = state.save_timestamp
			latest_slot = slot

	# No saves found
	if latest_slot < 0:
		print("âš  No saves found to reload")
		return false

	print("ðŸ”„ Reloading most recent save from slot " + str(latest_slot + 1) + " (saved at " + str(latest_timestamp) + ")")
	return load_and_apply(latest_slot)


## State Capture/Restore

func capture_state_from_game() -> GameState:
	"""Capture current game state from active Farm (from FarmView)

	Refactored for Farm/Biome/Qubit architecture:
	- Economy: All resource inventories
	- Plots: Configuration, planted/measured/entanglement state
	- Goals: Progress
	- Icons: Activation levels
	- Time: Biome elapsed time + sun/moon phase
	- Quantum State: Complete biome_state tree (sun qubit, icon qubits, emoji qubits)
	"""
	var state = GameState.new()

	# Phase 1: Use direct farm reference (simulation-only saves)
	var farm = active_farm
	if not farm:
		push_error("Farm not found - cannot capture state (is GameStateManager.active_farm set?)")
		return state

	# Meta
	state.scenario_id = current_scenario_id
	state.save_timestamp = Time.get_unix_time_from_system()
	state.game_time = current_state.game_time if current_state else 0.0

	# Grid Dimensions (from Farm)
	state.grid_width = farm.grid_width
	state.grid_height = farm.grid_height

	# Economy (from Farm.economy)
	var economy = farm.economy
	state.credits = economy.credits
	state.wheat_inventory = economy.wheat_inventory
	state.labor_inventory = economy.labor_inventory
	state.flour_inventory = economy.flour_inventory
	state.flower_inventory = economy.flower_inventory
	state.mushroom_inventory = economy.mushroom_inventory if economy.has_method("get_mushroom_inventory") else 0
	state.detritus_inventory = economy.detritus_inventory if economy.has_method("get_detritus_inventory") else 0
	state.imperium_resource = economy.imperium_resource if economy.has_method("get_imperium_resource") else 0
	state.tributes_paid = economy.total_tributes_paid if economy.has_method("get_tributes_paid") else 0
	state.tributes_failed = economy.total_tributes_failed if economy.has_method("get_tributes_failed") else 0

	# Plots (from Farm.grid)
	state.plots.clear()
	var grid = farm.grid
	for y in range(state.grid_height):
		for x in range(state.grid_width):
			var pos = Vector2i(x, y)
			var plot = grid.get_plot(pos)

			# Capture plot configuration and measurement state
			# NOTE: Quantum state details (theta, phi, radius, energy, berry_phase) are NOT saved
			#       They regenerate when plots are planted from the biome environment
			var plot_data = {
				"position": pos,
				"type": plot.plot_type,
				"is_planted": plot.is_planted,
				"has_been_measured": plot.has_been_measured,
				"theta_frozen": plot.theta_frozen,
				"entangled_with": plot.entangled_plots.keys()
			}
			# Phase 5.2: Serialize persistent gate infrastructure (Tool #2 gates)
		# These gates survive harvest/replant cycles
		if plot.has("persistent_gates"):
			var serialized_gates = []
			for gate in plot.persistent_gates:
				var serialized_gate = {
					"type": gate.get("type", ""),
					"active": gate.get("active", true)
				}
				# Serialize linked_plots (Array[Vector2i] â†’ Array[Dictionary])
				var linked_plots_serialized = []
				for linked_pos in gate.get("linked_plots", []):
					linked_plots_serialized.append({"x": linked_pos.x, "y": linked_pos.y})
				serialized_gate["linked_plots"] = linked_plots_serialized
				serialized_gates.append(serialized_gate)
			plot_data["persistent_gates"] = serialized_gates
		else:
			plot_data["persistent_gates"] = []

		state.plots.append(plot_data)

	# Goals
	var goals = farm.goals
	state.current_goal_index = goals.current_goal_index
	state.completed_goals.clear()
	for i in range(goals.goals_completed.size()):
		if goals.goals_completed[i]:
			state.completed_goals.append(goals.goals[i]["id"])

	# Icons (Phase 1: Now from Farm simulation layer)
	state.biotic_activation = farm.biotic_icon.active_strength if farm.biotic_icon else 0.0
	state.chaos_activation = farm.chaos_icon.active_strength if farm.chaos_icon else 0.0
	state.imperium_activation = farm.imperium_icon.active_strength if farm.imperium_icon else 0.0

	# Phase 2: Multi-Biome Capture
	# Capture quantum states from all registered biomes
	state.biome_states = _capture_all_biome_states(farm)

	# Capture plotâ†’biome assignments
	state.plot_biome_assignments = {}
	if farm.grid and farm.grid.has("plot_biome_assignments"):
		for pos_key in farm.grid.plot_biome_assignments.keys():
			state.plot_biome_assignments[pos_key] = farm.grid.plot_biome_assignments[pos_key]

	# LEGACY: Also populate old single-biome fields for backward compatibility
	# Use BioticFlux as the "primary" biome for old saves
	if state.biome_states.has("BioticFlux"):
		var bf = state.biome_states["BioticFlux"]
		state.time_elapsed = bf.get("time_elapsed", 0.0)
		if bf.has("sun_qubit"):
			state.sun_theta = bf["sun_qubit"].get("theta", 0.0)
			state.sun_phi = bf["sun_qubit"].get("phi", 0.0)
		state.biome_state = bf  # Copy full state for backward compat

	# Vocabulary Evolution State (PERSISTED - player's discovered vocabulary travels with them)
	if vocabulary_evolution:
		state.vocabulary_state = vocabulary_evolution.serialize()
		print("   ðŸ“š Captured vocabulary: %d discovered, %d evolving" % [
			state.vocabulary_state.get("discovered_vocabulary", []).size(),
			state.vocabulary_state.get("evolving_qubits", []).size()
		])

	# Conspiracy Network NOT saved (dynamic, regenerated each session)

	print("ðŸ“¸ Captured game state: grid=" + str(state.grid_width) + "x" + str(state.grid_height) +
		  ", plots=" + str(state.plots.size()) + ", credits=" + str(state.credits))
	return state


## Phase 2: Multi-Biome Capture Helpers

func _capture_all_biome_states(farm: Node) -> Dictionary:
	"""Capture quantum state from all registered biomes"""
	var all_states = {}

	# Capture each biome if it exists
	if farm.biotic_flux_biome:
		all_states["BioticFlux"] = _capture_single_biome_state(farm.biotic_flux_biome, "BioticFlux")
	if farm.market_biome:
		all_states["Market"] = _capture_single_biome_state(farm.market_biome, "Market")
	if farm.forest_biome:
		all_states["Forest"] = _capture_single_biome_state(farm.forest_biome, "Forest")
	if farm.kitchen_biome:
		all_states["Kitchen"] = _capture_single_biome_state(farm.kitchen_biome, "Kitchen")

	return all_states


func _capture_single_biome_state(biome: Node, biome_name: String) -> Dictionary:
	"""Capture quantum state from one biome"""
	var state_dict = {
		"time_elapsed": 0.0,
		"quantum_states": []
	}

	# Capture time
	if biome.has("time_elapsed"):
		state_dict["time_elapsed"] = biome.time_elapsed
	elif biome.has("time_tracker") and biome.time_tracker:
		state_dict["time_elapsed"] = biome.time_tracker.time_elapsed

	# Capture sun/moon qubit (BioticFlux specific)
	if biome_name == "BioticFlux" and biome.has("sun_qubit") and biome.sun_qubit:
		state_dict["sun_qubit"] = {
			"theta": biome.sun_qubit.theta,
			"phi": biome.sun_qubit.phi,
			"radius": biome.sun_qubit.radius,
			"energy": biome.sun_qubit.energy
		}

	# Capture icon states (if they have internal_qubit)
	if biome.has("wheat_icon") and biome.wheat_icon:
		if biome.wheat_icon is Dictionary and biome.wheat_icon.has("internal_qubit"):
			var iq = biome.wheat_icon["internal_qubit"]
			state_dict["wheat_icon"] = {
				"theta": iq.theta, "phi": iq.phi, "radius": iq.radius, "energy": iq.energy
			}
		elif biome.wheat_icon.has("internal_qubit"):
			var iq = biome.wheat_icon.internal_qubit
			state_dict["wheat_icon"] = {
				"theta": iq.theta, "phi": iq.phi, "radius": iq.radius, "energy": iq.energy
			}

	if biome.has("mushroom_icon") and biome.mushroom_icon:
		if biome.mushroom_icon is Dictionary and biome.mushroom_icon.has("internal_qubit"):
			var iq = biome.mushroom_icon["internal_qubit"]
			state_dict["mushroom_icon"] = {
				"theta": iq.theta, "phi": iq.phi, "radius": iq.radius, "energy": iq.energy
			}
		elif biome.mushroom_icon.has("internal_qubit"):
			var iq = biome.mushroom_icon.internal_qubit
			state_dict["mushroom_icon"] = {
				"theta": iq.theta, "phi": iq.phi, "radius": iq.radius, "energy": iq.energy
			}

	# Capture quantum states (all plot qubits in this biome)
	if biome.has("quantum_states"):
		for pos in biome.quantum_states.keys():
			var qubit = biome.quantum_states[pos]
			if qubit:
				var qubit_data = {
					"position": pos,
					"theta": qubit.theta,
					"phi": qubit.phi,
					"radius": qubit.radius,
					"energy": qubit.energy
				}
				# Include emoji axes if available
				if qubit.has("north_emoji"):
					qubit_data["north_emoji"] = qubit.north_emoji
				if qubit.has("south_emoji"):
					qubit_data["south_emoji"] = qubit.south_emoji
				state_dict["quantum_states"].append(qubit_data)

	# Phase 5.1: Capture gate infrastructure (Bell gates, CNOT gates, cluster gates)
	state_dict["bell_gates"] = []
	if biome.has("bell_gates"):
		for gate in biome.bell_gates:
			# Each gate is an array of Vector2i positions
			# Convert to serializable format (Array[Vector2i] â†’ Array[Dictionary])
			var gate_positions = []
			for pos in gate:
				gate_positions.append({"x": pos.x, "y": pos.y})
			state_dict["bell_gates"].append(gate_positions)

	# Phase 3: Capture bath-first mode state
	state_dict["use_bath_mode"] = biome.use_bath_mode if biome.has("use_bath_mode") else false

	if state_dict["use_bath_mode"] and biome.has("bath") and biome.bath:
		# Serialize QuantumBath amplitudes
		state_dict["bath_state"] = _serialize_bath_state(biome.bath)

		# Serialize active projections
		state_dict["active_projections"] = []
		if biome.has("active_projections"):
			for pos in biome.active_projections.keys():
				var proj_data = biome.active_projections[pos]
				state_dict["active_projections"].append({
					"position": pos,
					"north": proj_data.north,
					"south": proj_data.south
				})

	return state_dict


## Phase 2: Multi-Biome Restore Helpers

func _restore_all_biome_states(farm: Node, biome_states: Dictionary) -> void:
	"""Restore quantum states to all biomes"""
	for biome_name in biome_states.keys():
		var biome_state = biome_states[biome_name]
		var biome = null

		# Get biome reference by name
		match biome_name:
			"BioticFlux":
				biome = farm.biotic_flux_biome
			"Market":
				biome = farm.market_biome
			"Forest":
				biome = farm.forest_biome
			"Kitchen":
				biome = farm.kitchen_biome

		if biome:
			_restore_single_biome_state(biome, biome_state, biome_name)


func _restore_single_biome_state(biome: Node, state: Dictionary, biome_name: String) -> void:
	"""Restore quantum state to one biome"""

	# Restore time
	if state.has("time_elapsed"):
		if biome.has("time_elapsed"):
			biome.time_elapsed = state.time_elapsed
		elif biome.has("time_tracker") and biome.time_tracker:
			biome.time_tracker.time_elapsed = state.time_elapsed

	# Restore sun/moon qubit (BioticFlux specific)
	if biome_name == "BioticFlux" and state.has("sun_qubit") and biome.has("sun_qubit") and biome.sun_qubit:
		var sq = state.sun_qubit
		biome.sun_qubit.theta = sq.get("theta", 0.0)
		biome.sun_qubit.phi = sq.get("phi", 0.0)
		biome.sun_qubit.radius = sq.get("radius", 1.0)
		biome.sun_qubit.energy = sq.get("energy", 1.0)

	# Restore wheat icon (if has internal_qubit)
	if state.has("wheat_icon") and biome.has("wheat_icon") and biome.wheat_icon:
		var wi = state.wheat_icon
		if biome.wheat_icon is Dictionary and biome.wheat_icon.has("internal_qubit"):
			var iq = biome.wheat_icon["internal_qubit"]
			iq.theta = wi.get("theta", PI/4.0)
			iq.phi = wi.get("phi", 0.0)
			iq.radius = wi.get("radius", 1.0)
			iq.energy = wi.get("energy", 1.0)
		elif biome.wheat_icon.has("internal_qubit"):
			var iq = biome.wheat_icon.internal_qubit
			iq.theta = wi.get("theta", PI/4.0)
			iq.phi = wi.get("phi", 0.0)
			iq.radius = wi.get("radius", 1.0)
			iq.energy = wi.get("energy", 1.0)

	# Restore mushroom icon (if has internal_qubit)
	if state.has("mushroom_icon") and biome.has("mushroom_icon") and biome.mushroom_icon:
		var mi = state.mushroom_icon
		if biome.mushroom_icon is Dictionary and biome.mushroom_icon.has("internal_qubit"):
			var iq = biome.mushroom_icon["internal_qubit"]
			iq.theta = mi.get("theta", PI)
			iq.phi = mi.get("phi", 0.0)
			iq.radius = mi.get("radius", 1.0)
			iq.energy = mi.get("energy", 1.0)
		elif biome.mushroom_icon.has("internal_qubit"):
			var iq = biome.mushroom_icon.internal_qubit
			iq.theta = mi.get("theta", PI)
			iq.phi = mi.get("phi", 0.0)
			iq.radius = mi.get("radius", 1.0)
			iq.energy = mi.get("energy", 1.0)

	# Restore quantum states (emoji qubits)
	if state.has("quantum_states") and biome.has("quantum_states"):
		for qubit_data in state.quantum_states:
			var pos = qubit_data["position"]
			if biome.quantum_states.has(pos):
				var qubit = biome.quantum_states[pos]
				qubit.theta = qubit_data.get("theta", PI/2.0)
				qubit.phi = qubit_data.get("phi", 0.0)
				qubit.radius = qubit_data.get("radius", 0.3)
				qubit.energy = qubit_data.get("energy", 0.3)

	# Phase 5.1: Restore gate infrastructure (Bell gates, CNOT gates, cluster gates)
	if state.has("bell_gates") and biome.has("bell_gates"):
		biome.bell_gates.clear()
		for gate_data in state.bell_gates:
			# Convert serialized format back to Vector2i array
			var gate_positions = []
			for pos_dict in gate_data:
				gate_positions.append(Vector2i(pos_dict.x, pos_dict.y))
			biome.bell_gates.append(gate_positions)

	# Phase 3: Restore bath-first mode state
	if state.get("use_bath_mode", false):
		if biome.has("use_bath_mode"):
			biome.use_bath_mode = true

		# Wait for bath initialization (async process)
		if not biome.has("bath") or not biome.bath:
			await biome.get_tree().process_frame

		# Restore bath state
		if state.has("bath_state") and biome.has("bath") and biome.bath:
			_deserialize_bath_state(biome.bath, state.bath_state)

		# Recreate projections
		if state.has("active_projections") and biome.has_method("create_projection"):
			biome.active_projections.clear()
			for proj in state.active_projections:
				biome.create_projection(proj.position, proj.north, proj.south)


## Phase 3: Bath-First Serialization Helpers

func _serialize_bath_state(bath: Node) -> Dictionary:
	"""Convert QuantumBath to serializable dict (Phase 3)"""
	var serialized_amps = {}

	# Serialize Complex amplitudes to {real, imag} dictionaries
	for emoji in bath.emoji_list:
		var amp = bath.get_amplitude(emoji)
		serialized_amps[emoji] = {
			"real": amp.real,
			"imag": amp.imag
		}

	return {
		"emojis": bath.emoji_list.duplicate(),
		"amplitudes": serialized_amps,
		"bath_time": bath.bath_time
	}


func _deserialize_bath_state(bath: Node, state: Dictionary) -> void:
	"""Restore QuantumBath from serialized dict (Phase 3)"""
	const Complex = preload("res://Core/QuantumSubstrate/Complex.gd")

	# Restore amplitudes array
	for i in range(state.emojis.size()):
		var emoji = state.emojis[i]
		if state.amplitudes.has(emoji):
			var amp_data = state.amplitudes[emoji]
			var amp = Complex.new(amp_data.real, amp_data.imag)
			bath.amplitudes[i] = amp

	bath.bath_time = state.bath_time


func apply_state_to_game(state: GameState):
	"""Apply loaded state to active Farm (through FarmView)

	Refactored for Farm/Biome/Qubit architecture:
	- Loads economy, plot configuration, goals, time from GameState
	- Restores complete biome quantum state tree (all qubits)
	- UI layer (icons, visuals) updated through FarmView
	"""
	# Phase 1: Use direct farm reference (simulation-only saves)
	var farm = active_farm

	if not farm:
		push_error("Farm not found - cannot apply state (is GameStateManager.active_farm set?)")
		return

	# Phase 4: Validation
	# Version check
	if state.save_version != 1:
		push_error("Save file version mismatch: expected 1, got %d" % state.save_version)
		push_error("This save may be incompatible with current game version")
		# Continue anyway - attempt to load what we can

	# Grid size validation
	if farm.grid:
		if state.grid_width != farm.grid.grid_width or state.grid_height != farm.grid.grid_height:
			push_warning("Grid size mismatch: save has %dx%d, farm has %dx%d" % [
				state.grid_width, state.grid_height,
				farm.grid.grid_width, farm.grid.grid_height
			])
			push_warning("Out-of-bounds plots will be skipped")

	print("ðŸ”„ Applying game state to farm (" + str(state.grid_width) + "x" + str(state.grid_height) + ")...")

	# Apply Economy (from Farm.economy)
	var economy = farm.economy
	economy.credits = state.credits
	economy.wheat_inventory = state.wheat_inventory
	economy.labor_inventory = state.labor_inventory
	economy.flour_inventory = state.flour_inventory
	economy.flower_inventory = state.flower_inventory
	if economy.has_method("set_mushroom_inventory"):
		economy.set_mushroom_inventory(state.mushroom_inventory)
	if economy.has_method("set_detritus_inventory"):
		economy.set_detritus_inventory(state.detritus_inventory)
	if economy.has_method("set_imperium_resource"):
		economy.set_imperium_resource(state.imperium_resource)
	if economy.has_method("set_tributes"):
		economy.set_tributes(state.tributes_paid, state.tributes_failed)

	# Apply Plot Configuration (from Farm.grid)
	var grid = farm.grid
	for plot_data in state.plots:
		var pos = plot_data["position"]

		# Phase 4: Bounds checking - skip out-of-bounds plots
		if pos.x < 0 or pos.x >= grid.grid_width or pos.y < 0 or pos.y >= grid.grid_height:
			push_warning("Skipping out-of-bounds plot at %s (grid is %dx%d)" % [
				pos, grid.grid_width, grid.grid_height
			])
			continue

		var plot = grid.get_plot(pos)

		if plot:
			plot.plot_type = plot_data["type"]
			plot.is_planted = plot_data["is_planted"]

			# Measurement state (collapses quantum superposition)
			plot.has_been_measured = plot_data.get("has_been_measured", false)
			plot.theta_frozen = plot_data.get("theta_frozen", false)

			# Restore entanglement relationships
			plot.entangled_plots.clear()
			for entangled_pos in plot_data.get("entangled_with", []):
				var other_plot = grid.get_plot(entangled_pos)
				if other_plot:
					plot.entangled_plots[other_plot.plot_id] = 1.0

			# IMPORTANT: Quantum state details (theta, phi, radius, energy, berry_phase)
			# are NOT restored - they regenerate from the biome when the plot is replanted.
			# This keeps the save format simple and maintains deterministic behavior through
			# the infrastructure model (entanglement gates persist, qubits regenerate).

	# Apply Goals
	var goals = farm.goals
	goals.current_goal_index = state.current_goal_index
	goals.goals_completed.clear()
	for goal in goals.goals:
		var is_completed = state.completed_goals.has(goal["id"])
		goals.goals_completed.append(is_completed)
		goal["completed"] = is_completed

	# Phase 2: Multi-Biome Restore
	# Restore plotâ†’biome assignments FIRST (before restoring states)
	if state.plot_biome_assignments and farm.grid:
		if farm.grid.has("plot_biome_assignments"):
			farm.grid.plot_biome_assignments = state.plot_biome_assignments.duplicate()

	# Restore quantum states to all biomes
	if state.biome_states:
		_restore_all_biome_states(farm, state.biome_states)
	elif state.biome_state:
		# LEGACY: Old saves only have single biome_state - restore to BioticFlux
		if farm.biotic_flux_biome:
			_restore_single_biome_state(farm.biotic_flux_biome, state.biome_state, "BioticFlux")

	# Apply Icon Activation (Phase 1: Now from Farm simulation layer)
	if farm.biotic_icon and farm.biotic_icon.has_method("set_activation"):
		farm.biotic_icon.set_activation(state.biotic_activation)
	if farm.chaos_icon and farm.chaos_icon.has_method("set_activation"):
		farm.chaos_icon.set_activation(state.chaos_activation)
	if farm.imperium_icon and farm.imperium_icon.has_method("set_activation"):
		farm.imperium_icon.set_activation(state.imperium_activation)

	# Restore Vocabulary Evolution State (PERSISTED - player's discovered vocabulary)
	if vocabulary_evolution and state.vocabulary_state:
		vocabulary_evolution.deserialize(state.vocabulary_state)
		print("   ðŸ“š Restored vocabulary evolution from save")

	# Conspiracy Network NOT loaded (dynamic, regenerate each session)

	# Phase 5: Visualizer Rebuild Strategy
	# ARCHITECTURE: GameStateManager (simulation layer) doesn't access UI visualizers directly
	#
	# Automatic rebuild via signals:
	# - ResourcePanel: âœ… Already rebuilds via economy.resource_changed (emitted above)
	# - PlotGridDisplay: âœ… Has rebuild_from_grid() method (UI layer calls it after load)
	# - QuantumForceGraph: âœ… Has rebuild_from_biomes() method (UI layer calls it after load)
	#
	# The UI layer (FarmView/FarmUI) is responsible for calling rebuild methods after
	# GameStateManager.apply_state_to_game() completes. This maintains clean separation:
	# - Simulation layer (this file) restores game state
	# - UI layer responds by rebuilding visualizations
	#
	# NOTE: Economy signals are automatically emitted when we set wheat_inventory etc above,
	# so ResourcePanel updates happen automatically. Other visualizers need explicit rebuild.

	print("âœ“ State applied to farm successfully - quantum states will regenerate from biome")


## Scenario Completion Tracking

func mark_scenario_completed(scenario_id: String):
	"""Mark scenario as completed (unlocks next scenarios)"""
	var completed = _load_completed_scenarios()
	if scenario_id not in completed:
		completed.append(scenario_id)
		_save_completed_scenarios(completed)
		print("ðŸ† Scenario completed: " + scenario_id)

func is_scenario_completed(scenario_id: String) -> bool:
	"""Check if player has completed this scenario"""
	var completed = _load_completed_scenarios()
	return scenario_id in completed

func get_completed_scenarios() -> Array[String]:
	"""Get list of all completed scenarios"""
	return _load_completed_scenarios() as Array[String]

func clear_completed_scenarios():
	"""Clear all completed scenarios (for testing/reset)"""
	_save_completed_scenarios([])
	print("ðŸ”„ Cleared all completed scenarios")

func _load_completed_scenarios() -> Array:
	"""Load completed scenarios from save file"""
	var completed_file = SAVE_DIR + "completed_scenarios.json"
	if not FileAccess.file_exists(completed_file):
		return []

	var file = FileAccess.open(completed_file, FileAccess.READ)
	if file:
		var json_string = file.get_as_text()
		var json = JSON.parse_string(json_string)
		if json and json is Array:
			return json
	return []

func _save_completed_scenarios(completed: Array):
	"""Save completed scenarios to save file"""
	var completed_file = SAVE_DIR + "completed_scenarios.json"
	var file = FileAccess.open(completed_file, FileAccess.WRITE)
	if file:
		var json_string = JSON.stringify(completed)
		file.store_string(json_string)

## Restart

func restart_current_scenario():
	"""Restart by reloading current scenario (not scene reload!)"""
	print("ðŸ”„ Restarting scenario: " + current_scenario_id)
	var state = new_game(current_scenario_id)
	apply_state_to_game(state)


## Persistent Vocabulary Access

func get_vocabulary_evolution() -> VocabularyEvolution:
	"""Get the persistent vocabulary evolution system

	The vocabulary persists across farm/biome changes and travels with the player.
	This ensures discovered vocabulary remains available even when switching contexts.
	"""
	if not vocabulary_evolution:
		# Safety fallback - should not happen if _ready() was called
		vocabulary_evolution = VocabularyEvolution.new()
		vocabulary_evolution._ready()
		add_child(vocabulary_evolution)

	return vocabulary_evolution
